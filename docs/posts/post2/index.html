<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Michael Kumi">
<meta name="dcterms.date" content="2023-09-13">

<title>Michael Kumi - RETENTION PREDICTION FOR CAR INSURANCE</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Michael Kumi</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/HighestMike" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/michael-kumi-043022211?lipi=urn%3Ali%3Apage%3Ad_flagship3_profile_view_base_contact_details%3BPwFSW6B8Su%2BEqMJGlhtzTw%3D%3D" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://mr.michaelkumi@gmail.com" rel="" target=""><i class="bi bi-gmail" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">RETENTION PREDICTION FOR CAR INSURANCE</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Project</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Michael Kumi </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 13, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">INTRODUCTION</h2>
<p>Insurance is a form of a risk management contract, represented by a policy, in which the policyholder pays an insurance firm in exchange for financial security or reimbursement against uncertain losses or specific contingencies. Health, auto, life, and travel insurance are just a few of the various forms of insurance available. Auto insurance, specifically car insurance of the most prevalent types of personal insurance often required by law, that provides protection in the event that a person’s vehicle is damaged, stolen or involved in an accident. Premium, policy limit and deductibles are three crucial insurance policy elements that are frequently taken into account when picking the best insurance policy to suit an individual or an institution. For the long-term survival of an insurance company, it is important to focus on customer retention. Customer retention is a term that assesses customer loyalty, or an organization’s capacity to maintain its client over time. Many factors may influence an insurance company’s client retention rates. The research aims to understand the factors related to the retention of car insurance customers for an insurance company. We will build a model to help us understand the relationship between these factors and retention, access our model with another dataset to see how well we can predict the given response and also compare our prediction error with a null model that always predicts (Retention = 1) and results in a classification error of 0.26.</p>
</section>
<section id="data-overview-and-visualization" class="level2">
<h2 class="anchored" data-anchor-id="data-overview-and-visualization">DATA OVERVIEW AND VISUALIZATION</h2>
<p>The dataset for this project contains covariates or potential factors that could affect the retention of the car insurance policy. This section aims to create plots and graphs to help us understand the relationships that exist between the retention of the policy and the various factors that might influence this variable. The dataset contains 30,000 observations and the variables collected on the various customers can be explained with the descriptions below.</p>
<ul>
<li><strong>Age_client</strong>: the age of the customer in years.</li>
<li><strong>Age_car</strong>: the number of years since the vehicle was bought by the customer.</li>
<li><strong>Driver2:</strong> 1 if the customer has informed the insurance company that a second occasional driver uses the vehicle, and 0 otherwise.</li>
<li><strong>Client_seniority</strong> is the number of years that the customer has been in the company.</li>
<li><strong>Retention</strong> equals 1 if the policy is renewed and 0 otherwise.</li>
<li><strong>Payment_annual</strong> 1 for annual payment and 0 for monthly payment.</li>
</ul>
<p>To explore the dataset, we will first check the relationship between the age of the customer and the retention of the policy. From figure 1, we can see that 22,314 individuals renewed their policy and 7686 individuals did not renew their policy. Also, we observe that those who renewed their policies had an average age higher than those who did not renew their policies but on average most of the customers were in their late 50s and the spread between the groups is not so different. Figure 2 is looking at these same variables, but this is classified based on whether they have an annual payment or monthly payment. From this figure, it is interesting to see that there are some differences based on the payment method of the customer and their respective ages. People with annual payments tend to be older as compared to those who have monthly payments.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-3_f288f6523160c6552d7d67c8941a6ef7">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" style="width:50.0%"></p>
</div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-4_8c1af2b2bcba3ad6472df0b02cd8be33">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid" style="width:50.0%"></p>
</div>
</div>
<p>Since we have a binary response, we can also consider the retention of the policies in terms of the probability that the client will renew their policy. Figure 2 shows a smoothing estimate using the locally estimated scatter plots smoothing of how retention changes across the different age groups based on the payment method. We can see that the proportion of policies that were renewed among young customers was higher for those with annual payments as compared to those with monthly payments making the slope for the two payment methods different. We look at this same relationship but with the client’s seniority in place of the age in figure 2. From this figure, older customers or clients who have annual payments have a higher renewal rate as compared to those with monthly installments.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-6_c53f1a9c5c5fcbcc54e5e8a98fc45251">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid" style="width:50.0%"></p>
</div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-7_48dd176e8031473c277abaef4656b4c6">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" style="width:50.0%"></p>
</div>
</div>
</section>
<section id="statistical-precedures" class="level2">
<h2 class="anchored" data-anchor-id="statistical-precedures">STATISTICAL PRECEDURES</h2>
<p>For this section, we aim at building a model to help us understand and know which variables influence or affect the retention of the car insurance policy and also derive a strategy to help us make predictions with the finalized model to help answer the research question. The first thing we can look at to guide us with which statistical model will be most appropriate is the structure of the response variable. The response variable in question has binary outcomes and this changes a lot about how the statistical analysis should be carried out. Linear regression is an additive model and would not work for binary outcomes. Therefore we will need a model that has the features of transforming the bounds of our outputs to the range of 0 and 1. The logistic regression would be appropriate for this situation. The logistic regression will treat the resulting values as probabilities which will then help us map them into random binary outcomes. We will define our logistics regression model as;</p>
<p><span class="math display">\[y_i\sim Bernouli(p_i)\]</span> <span class="math display">\[Pr(y_i = 1) = p_i\]</span> <span class="math display">\[\text{logit}(p_i) = X_i\beta\]</span></p>
<p>where <span class="math inline">\(y_i\)</span> is the response variable indicating whether or not a client will renew their policy, <span class="math inline">\(\text{logit}\)</span> is the link function, and <span class="math inline">\(X_i\beta\)</span> is our linear predictors under the assumption that the outcomes are independent given these probabilities. This next step is to discuss the variables to be included in our defined model. Looking at the provided dataset, we were given five possible factors that could influence the renewal rate of the car insurance policy. The first model we will consider will be a logistic regression model that contains all the provided independent variables as linear predictors. We will fit our models with the <code>glm</code> function from the <code>stats</code> package which is used to fit generalized linear models, specified by giving a symbolic description of the linear predictor. The generalized linear model is an extension of ordinary linear regression, where the linear model is related to the response variable via the link function.</p>
<p>For the second model, we will look at some interactions for some specific variables in addition to the model we defined as our first model. The reason why we consider interactions is that sometimes one independent variable depends on the outcome of another independent variable to explain the response. There could be situations where our response varies when an observation belongs to a specific group of another variable and influences its relationship with another explanatory variable. In this case, the slopes between these two groups under this relationship will differ making it very important to check for possible interactions and is best detected by visualizing your data with graphs. From Figure 3, we saw that there were some differences in the slope based on the payment method of the client hinting to us about possible interactions. Our proposed second model will consider an interaction between the age and the payment method, the client’s seniority and the age of the car as well as the age of the client and the age of the car. We will also consider another model with any possible interactions between all the variables in the model.</p>
<p>After fitting the three proposed logistic regression models, we can use AIC to assess the performance of the models and aid in the model selection. The Akaike information criterion (AIC) is defined as AIC = deviance + 2k, where k is the number of coefficients in the model. The best-fit model according to AIC is the one that explains the greatest amount of variation using the fewest possible independent variables and a lower AIC value indicates a better model.</p>
<p>Table 1 shows the AIC scores for the selected models and based on these values, we can say that for the given data, the best model according to the AIC is our logistic regression model which considers the interaction between the age and the payment method, the client’s seniority and the age of the car, and the age of the client and the age of the insured car. The final model is defined as;</p>
<p><span class="math display">\[
\operatorname{Pr}\left(\text { Retention }_i=1\right)=p_i
\]</span> <span class="math display">\[
\operatorname{logit}\left(p_i\right)=\beta_0+\beta_1 * \text{ Age-client }_i+\beta_2 * \text{ Age-car }_i+\beta_3 * \text{ Driver1 }_i+\beta_4 * \text{ Payment-annual1 }_i+
\]</span> <span class="math display">\[
\beta_5 * \text{ Client-seniority }_i+\beta_6 * \text{ Age-client }_i * \text{ Payment-annual1 }_i+\beta_7 * \text{ Age-car }_i * \text { Client-seniority }_i+
\]</span> <span class="math display">\[
\beta_8 * \text { Age-client }_i * \text { Age-car }_i
\]</span></p>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">RESULTS</h2>
<p>Table 2 is a summary of the parameter estimates from our final model together with their standard errors which is a measure of uncertainty for the coefficient. The coefficients of our model are on a logit scale and we can change them to probabilities by transforming the linear predictors of the model using the inverse logit function to get the probability that they will renew their policy <strong>(Pr(Retention = 1))</strong>. The coefficients can also be viewed in terms of the odd ratio by exponentiating our coefficients. Therefore to interpret the coefficient for the age of the client, we can say that a difference of 1 in the age of the client corresponds to a positive difference of 0.034 on a logit scale of renewing their policy and this estimate will be within the interval of 0.028 and 0.04 approximately 95% of the time. The intercept is interpreted assuming zero values for all the other continuous predictors and the reference group for the binary categorical variables and from Table 2 we have an estimate of -1.961 and a 95% confidence interval of -2.251 and -1.671 on a logit scale. For the coefficient of <code>Payment_annual1</code>, we can say that a client who pays annually has an expected difference of 0.436 higher with a 95% confidence interval of 0.16 and 0.712 on a logit scale of renewing their policy as compared to those of are enrolled on the monthly payment scheme. The interaction term is looking at the difference in slope on a logit scale. The coefficients of our interaction terms are almost close to zero. Meaning when we find the inverse logit, they will be also close to 0.5 representing a 50-50 chance of the customers renewing their policy hence these coefficients does not influence the probability of renewal that much. The standard errors for these coefficients are also close to 0 on a logit scale.</p>
<p>Figure 5 shows a visual representation of estimates and their 95% confidence intervals for the coefficients of our selected model. The figure helps us to get a clear picture of which coefficients of the model have a higher, lower, or no impact on the retention of the car insurance policy for the insurance company on a logit scale.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-13_f19ee94babecb618c4b4d1315e767078">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-13-1.png" class="img-fluid" style="width:50.0%"></p>
</div>
</div>
<p>The insurance also provided an additional dataset that can be used as test data to access the predictive ability of our model. We will adopt the strategy of using the covariates from this test model to predict the retention of the policies and since we know the true values, we can check how accurate our predictions are. We can use the classification error approach which tells us the number of misclassified outcomes by our model predictions out of the total number of responses to predict from the test data.</p>
<p>After we have made predictions with our model on the test data, table 3 is the classification table for our predicted vs true values, and this results in a classification error of 0.256. This means that about 26% of the time, our model predictions for the outcomes of the test data were misspecified.</p>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">DISCUSSION</h2>
<p>Our research question was to know which factors influence the retention of the insurance policy and also build a model to help us make predictions given the provided covariates. A logistic regression model was considered to model our response since we have a binary outcome of whether the clients renewed their policy or not. The final selected model based on the Akaike information criterion was an interaction model that included all our covariates and an interaction between the age and the payment method, the client’s seniority and the age of the car as well as the age of the client and the age of the car. Our model also showed that the client seniority had the greatest impact on the policy renewal compared to the other coefficients like the age of the client on a logit scale. After making predictions with this model and the additional data provided by the car insurance company, the classification error for the prediction of retention was about 0.256. Also from the research question, we want to compare our prediction error with a null model that always predicts (Retention = 1) and results in a classification error of 0.26. Table 4 represents the structure of this null model.</p>
<p>Using the null model as a basis for comparison, from table 5 we can see that our final model resulted in a classification error similar to the null model. We can use a proportion test to check if we can say our model is different from this null model in terms of the classification error. The one categorical proportion test produced a 95% confidence interval that contained the null value classification error of 0.26. Therefore we cannot say that our final selected model predicts retention differently from a null model that only predicts that a policyholder will renew their policy. Our results can only be generalized to this data from the insurance company since we don’t have a dataset from a random sample of all car insurance policies.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">REFERENCES</h2>
<p>Gelman, Andrew, Jennifer Hill, and Aki Vehtari. Regression and other stories. Cambridge University Press, 2020.</p>
<p>glm: Fitting Generalized Linear Models https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/glm</p>
<p>Violin plot with included boxplot and sample size in ggplot2 Holtz https://r-graph-gallery.com/violin_and_boxplot_ggplot2.html</p>
<p>Interpreting results from logistic regression in R using Titanic dataset Koh https://medium.com/<span class="citation" data-cites="conankoh/interpreting-results-from-logistic-regression-in-r-using-titanic-dataset-bb9f9a1f644c">(<a href="#ref-conankoh/interpreting-results-from-logistic-regression-in-r-using-titanic-dataset-bb9f9a1f644c" role="doc-biblioref"><strong>conankoh/interpreting-results-from-logistic-regression-in-r-using-titanic-dataset-bb9f9a1f644c?</strong></a>)</span></p>
<p>Logistic regression + histogram with ggplot2 PaoloCrosettoPaoloCrosetto 58011 gold badge77 silver badges1616 bronze badges &amp; ThierryThierry 17.9k55 gold badges4646 silver badges6565 bronze badges https://stackoverflow.com/questions/33521539/logistic-regression-histogram-with-ggplot2</p>
<p>change coefficient names in coefplot.glm() Ivo et al. https://stackoverflow.com/questions/59036723/change-coefficient-names-in-coefplot-glm</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>